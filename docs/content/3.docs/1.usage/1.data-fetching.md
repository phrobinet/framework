# Data Fetching

Nuxt fournit `useFetch`, `useLazyFetch`, `useAsyncData` et `useLazyAsyncData` pour g√©rer la r√©cup√©ration de donn√©es dans votre application.

::alert{icon=üëâ}
**`useFetch`, `useLazyFetch`, `useAsyncData` et `useLazyAsyncData` ne fonctionne que pendant `setup` ou `Lifecycle Hooks`**
::

## `useAsyncData`

Dans vos pages, composants et plugins, vous pouvez utiliser `useAsyncData` pour acc√©der √† des donn√©es qui se r√©solvent de mani√®re asynchrone.

### Usage

```js
const {
  data: Ref<DataT>,
  pending: Ref<boolean>,
  refresh: (force?: boolean) => Promise<void>,
  error?: any
} = useAsyncData(
  key: string,
  fn: () => Object,
  options?: { lazy: boolean, server: boolean }
)
```

**key** : une cl√© unique pour s'assurer que la r√©cup√©ration des donn√©es peut √™tre correctement d√©-dupliqu√©e √† travers les requ√™tes.
**fn** : une fonction asynchrone qui renvoie une valeur.
* **options** :
  * _lazy_ : si la fonction asynchrone doit √™tre r√©solue apr√®s le chargement de la route, au lieu de bloquer la navigation (par d√©faut `false`)
  * _default_ : une fonction d'usine pour d√©finir la valeur par d√©faut des donn√©es, avant la r√©solution de la fonction asynchrone - particuli√®rement utile avec l'option `lazy : true`.
  * _server_ : si les donn√©es doivent √™tre r√©cup√©r√©es c√¥t√© serveur (par d√©faut √† `true`)
  * _transform_ : Une fonction qui peut √™tre utilis√©e pour modifier le r√©sultat du fn apr√®s la r√©solution.
  * _pick_ : R√©cup√©rer uniquement les cl√©s sp√©cifi√©es dans ce tableau √† partir du r√©sultat du fn.

`useAsyncData` retourne un objet avec les propri√©t√©s suivantes :

* **data** : le r√©sultat de la fonction asynchrone qui est pass√© dans
* **pending** : un bool√©en indiquant si les donn√©es sont toujours en cours de r√©cup√©ration.
* **refresh** : une fonction qui peut √™tre utilis√©e pour forcer un rafra√Æchissement des donn√©es.
* **error** : un objet d'erreur si la r√©cup√©ration des donn√©es a √©chou√©.

Sous le capot, `lazy : false` utilise `<Suspense>` pour bloquer le chargement de la route avant que les donn√©es aient √©t√© r√©cup√©r√©es. Pensez √† utiliser `lazy : true` et √† impl√©menter un √©tat de chargement √† la place pour une exp√©rience utilisateur plus rapide.

### Exemple

```js [server/api/count.ts]
let counter = 0
export default () => {
  counter++
  return JSON.stringify(counter)
}
```

```vue [app.vue]
<script setup>
const { data } = await useAsyncData('count', () => $fetch('/api/count'))
</script>

<template>
  Page visits: {{ data }}
</template>
```

## `useLazyAsyncData`

Ce composable se comporte de la m√™me mani√®re que `useAsyncData` avec l'option `lazy : true` d√©finie. En d'autres termes, la fonction asynchrone ne bloque pas la navigation. Cela signifie que vous devrez g√©rer la situation o√π les donn√©es sont `null` (ou toute autre valeur que vous avez fournie dans une fonction d'usine `default` personnalis√©e).

## `useFetch`

Dans vos pages, composants et plugins, vous pouvez utiliser `useFetch` pour r√©cup√©rer universellement des donn√©es depuis n'importe quelle URL.

Ce composable fournit une enveloppe pratique autour de `useAsyncData` et `$fetch`. Il g√©n√®re automatiquement une cl√© bas√©e sur l'URL et les options de r√©cup√©ration, et d√©duit le type de r√©ponse de l'API.

### Usage

```ts
const {
  data: Ref<DataT>,
  pending: Ref<boolean>,
  refresh: (force?: boolean) => Promise<void>,
  error?: any
} = useFetch(url: string, options?)
```

Options disponibles :

* `key`: Fournir une cl√© personnalis√©e
* Options de [ohmyfetch](https://github.com/unjs/ohmyfetch)
  * `method` : M√©thode de requ√™te
  * `params` : Param√®tres de la requ√™te
  * `baseURL` : URL de base pour la requ√™te
* Options de `useAsyncData`
  * `lazy`
  * `server`
  * `default`
  * `pick`
  * `transform`

L'objet retourn√© par `useFetch` a les m√™mes propri√©t√©s que celui retourn√© par `useAsyncData` ([voir ci-dessus](#useasyncdata)).

### Exemple

```vue [app.vue]
<script setup>
const { data } = await useFetch('/api/count')
</script>

<template>
  Page visits: {{ data.count }}
</template>
```

## `useLazyFetch`

Ce composable se comporte de mani√®re identique √† `useFetch` avec l'option `lazy : true` d√©finie. En d'autres termes, la fonction asynchrone ne bloque pas la navigation. Cela signifie que vous devrez g√©rer la situation o√π les donn√©es sont `null` (ou toute autre valeur que vous avez fournie dans une fonction d'usine `default` personnalis√©e).

## Meilleures pratiques

Les donn√©es renvoy√©es par ces composables seront stock√©es dans la charge utile de la page. Cela signifie que chaque cl√© retourn√©e qui n'est pas utilis√©e dans votre composant sera ajout√©e √† la charge utile.

::alert{icon=üëâ}
**Nous vous recommandons fortement de ne s√©lectionner que les cl√©s que vous utiliserez dans votre composant.**
::

Imaginez que `/api/mountains/everest` renvoie l'objet suivant :

```json
{
  "title": "Mount Everest",
  "description": "Mount Everest is Earth's highest mountain above sea level, located in the Mahalangur Himal sub-range of the Himalayas. The China‚ÄìNepal border runs across its summit point",
  "height": "8,848 m",
  "countries": [
    "China",
    "Nepal"
  ],
  "continent": "Asia",
  "image": "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Everest_kalapatthar.jpg/600px-Everest_kalapatthar.jpg"
}
```

Si vous pr√©voyez d'utiliser uniquement `title` et `description` dans votre composant, vous pouvez s√©lectionner les cl√©s en encha√Ænant le r√©sultat de l'option `$fetch` ou `pick` :

```vue
<script setup>
const { data: mountain } = await useFetch('/api/mountains/everest', { pick: ['title', 'description'] })
</script>

<template>
  <h1>{{ mountain.title }}</h1>
  <p>{{ mountain.description }}</p>
</template>
```

## Utilisation de la configuration asynchrone

Si vous utilisez `async setup()`, l'instance actuelle du composant sera perdue apr√®s le premier `await`. (C'est une limitation de Vue 3.) Si vous voulez utiliser plusieurs op√©rations asynchrones, comme plusieurs appels √† `useFetch`, vous devrez utiliser `<script setup>` ou les attendre ensemble √† la fin du setup.

::alert{icon=üëâ}
L'utilisation de `<script setup>` est recommand√©e, car elle supprime la limitation de l'utilisation des attentes de niveau sup√©rieur. [Lire la suite](https://v3.vuejs.org/api/sfc-script-setup.html#top-level-await)
::

```vue
<script>
export default defineComponent({
  async setup() {
    const [{ data: organization }, { data: repos }] = await Promise.all([
      useFetch(`https://api.github.com/orgs/nuxt`),
      useFetch(`https://api.github.com/orgs/nuxt/repos`)
    ])

    return {
      organization,
      repos
    }
  }
})
</script>

<template>
  <header>
    <h1>{{ organization.login }}</h1>
    <p>{{ organization.description }}</p>
  </header>
</template>
```
